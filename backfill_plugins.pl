#!/usr/bin/perl

# This script locates any unlabeled NASL files (recent releases, etc) and updates the
# Alienvault SID table with the plugin name, priority and name.

use Getopt::Std;
use Data::Dumper;
use DBI;
use strict;



use File::Find qw(finddepth);
 my @files;
finddepth(sub {
            return if($_ eq '.' || $_ eq '..');
            push @files, $File::Find::name;
          }, '/var/lib/openvas/plugins/');

my $content;

my $reconfig=0;

# Reads en entire file for processing
sub read_file
  {
    my $filename = @_[0];
    #print "$filename\n";
    my $localcontent;
    open(my $fh, '<', $filename) or die "cannot open file $filename";
    {
      local $/;
      $localcontent = <$fh>;
    }
    close($fh);
    return $localcontent;
  }

# Extracts out a value until a closing parenthesis 
sub cparen{
    my ($value) = $content =~ m/@_\(\s*\"?([^"]*?)\"?\s*\)\s*\;/;
    return $value;
  }

# Finds pairs based on field name.
sub named_pair{
    my ($value) = $content =~ m/name\:\s*\"@_\",\s*value:\s*\"?(.*?)\"?\);/;
    return $value;
  }

# Finds pairs based on what the first half (the variable) is equal to.
sub equal_pair{
    my ($value) = $content =~ m/@_\s*=\s*(.*);/;
    return $value;
  }

# Converts priorities into numerical representations. 
sub parse_priority
  {

    my $priority=@_[0];

    if( $priority eq "None" )
      {
        return 0;
      }
    if( $priority eq "Low" )
      {
        return 1;
      }
    if( $priority eq "Medium" )
      {
        return 2;
      }
    if( $priority eq "High" )
      {
        return 3;
      }
    if( $priority eq "Critical" )
      {
        return 4;
      }
    return 10;
  }

# This is a big improvement over Alienvault's internal mechanisms for 
# assigning values. Based on the attack vectors that have been documented 
# and associated with a given CVSS base score we can easily prioritize these ourself
# http://nvd.nist.gov/cvss.cfm

sub parse_vector
  {
    my $retval=0;

    my $vector = @_[0];
    #print "$vector\n";

    my %lhash = split /[:\/]/, $vector;

    if( $lhash{"AV"} eq "N" )
      {
        #print "AV=N Increment the retval by 2\n";
        $retval+=2;
      }
    if( $lhash{"AV"} eq "A" )
      {
        #print "AV=A Increment the retval by 1\n";
        $retval+=1;
      }

    if( $lhash{"AC"} eq "M" )
      {
        #print "AC=M Increment the retval by 1\n";
        $retval+=1;
      }
    if( $lhash{"AC"} eq "L" )
      {
        #print "AC=L Increment the retval by 2\n";
        $retval+=2;
      }

    if( $lhash{"Au"} eq "N" )
      {
        #print "Au=N Increment the retval by 2\n";
        $retval+=2;
      }

    if( $lhash{"Au"} eq "S" )
      {
        #print "Au=S Increment the retval by 1\n";
        $retval+=1;
      }

    if( $lhash{"C"} eq "P" )
      {
        #print "C=P Increment the retval by 1\n";
        $retval+=1;
      }
    if( $lhash{"C"} eq "C" )
      {
        #print "C=C Increment the retval by 2\n";
        $retval+=2;
      }

    if( $lhash{"I"} eq "P" )
      {
        #print "I=P Increment the retval by 1\n";
        $retval+=1;
      }
    if( $lhash{"I"} eq "C" )
      {
        #print "I=C Increment the retval by 2\n";
        $retval+=2;
      }

    if( $lhash{"A"} eq "P" )
      {
        #print "A=P Increment the retval by 1\n";
        $retval+=1;
      }
    if( $lhash{"A"} eq "C" )
      {
        #print "A=C Increment the retval by 2\n";
        $retval+=2;
      }
    $retval = int( $retval/2);
    #print "Returning $retval\n";
    return $retval;
  }



my $dbhost = `grep ^ossim_host= /etc/ossim/framework/ossim.conf | cut -f 2 -d "="`; chomp($dbhost);
$dbhost = "localhost" if ($dbhost eq "");
my $dbuser = `grep ^ossim_user= /etc/ossim/framework/ossim.conf | cut -f 2 -d "="`; chomp($dbuser);
my $dbpass = `grep ^ossim_pass= /etc/ossim/framework/ossim.conf | cut -f 2 -d "="`; chomp($dbpass);


my $database="alienvault";
my $dsn = "dbi:mysql:$database:localhost:3306";

#print "$dbhost\n";
#print "$dbuser\n";
#print "$dbpass\n";


# Connect to the SQL database
my $dbh = DBI->connect($dsn, $dbuser , $dbpass)
 or die "Connection Error: $DBI::errstr\n";

my $sql;
my $sth;

$sql="delete from plugin_sid where plugin_id=3001;";
print "$sql\n";
$sth = $dbh->prepare($sql);
$sth->execute or die "SQL Error: $DBI::errstr\n";

foreach ( @files )
  {
    # Parse and read each file.
    $content = read_file $_;
    my $script_id =          cparen "script_id";


    my $filename = $_;
    #print  "File Name:        $filename\n";
    #print  "Script ID:        $script_id\n";


    if( $script_id != ''  ) # && ! ( exists $sids->{ $script_id }->{sid} )  )
      {
        # Some older scripts don't have a script id. Ignore them.
        # Some scripts will already have a valid SID in the database. Ignore them.

        # Although multiple fields are extracted here most of them aren't needed.

        my $script_cve_id =      cparen "script_cve_id";
        my $script_bugtraq_id =  cparen "script_bugtraq_id";
        my $cvss_base =          named_pair "cvss_base";
        my $risk_factor =        named_pair "risk_factor";
        my $last_modified =      named_pair "last_modification";
        my $script_name =        cparen "script_name";

        my $name =               equal_pair "name";
        #print "===> $name\n";

        my $vector =             named_pair "cvss_base_vector";

        my $reliability =        parse_vector $vector;
        my $priority =           parse_priority $risk_factor;


        # print  "Script ID:        $script_id\n";
        # print  "CVE ID:           $script_cve_id\n";
        # print  "Bugtrack ID:      $script_bugtraq_id\n";
        # print  "CVSS Base:        $cvss_base\n";
        # print  "Risk Factor:      $risk_factor\n";
        # print  "Script Name:      $script_name\n";
        # print  "Last Modified:    $last_modified\n";
        # print  "Vector:           $vector\n";
        # print  "Reliability:      $reliability\n";
        # print  "Priority:         $priority\n";
        # print  "---------------------------\n";


        if( $script_name eq "name" )
          {
            #print  "--------------- $script_name\n";
            #print  "--------------- $name\n";

            $script_name = $name;
            $script_name =~ s/"//g;
          }

        $sql = "insert ignore into plugin_sid values( 0x0, 3001, $script_id, null, $reliability, $priority, \"nessus: $script_name\", 0, null, null );";
        #print "$sql\n";
        $sth = $dbh->prepare($sql);
        $sth->execute or die "SQL Error: $DBI::errstr\n";
        $reconfig++;
      }
  }


  # Increase the reliability of the default SID. This will cause generic events for any assets
  # with a value of 2 or higher to create alerts (it bumps the risk value over 1).
  $sql="update plugin_sid_changes set reliability=7 where sid=2000000000 and plugin_id=3001;";
  $sth = $dbh->prepare($sql);
  $sth->execute or die "SQL Error: $DBI::errstr\n";


# The following will automatically run a reconfig. This is required to use these updated values.  
#`/usr/bin/sudo /usr/bin/alienvault-reconfig`

#exit 0;
